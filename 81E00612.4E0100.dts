
/dts-v1/;

/ {
	name = "";
	compatible = "ibm,opal-in-memory-counters";
	#address-cells = <0x1>;
	#size-cells = <0x1>;
	imc-nest-offset = <0x180000>;
	imc-nest-size = <0x40000>;
	version-id = <0xd>;

NEST_MCS: nest-mcs-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "RRTO_QFULL_NO_DISP" ;
			reg = <0x0 0x8>;
			desc = "RRTO not dispatched in MCS due to capacity - pulses once for each time a valid RRTO op is not dispatched due to a command list full condition" ;
		};
		event@8 {
			event-name = "WRTO_QFULL_NO_DISP" ;
			reg = <0x8 0x8>;
			desc = "WRTO not dispatched in MCS due to capacity - pulses once for each time a valid WRTO op is not dispatched due to a command list full condition" ;
		};
		event@10 {
			event-name = "AMO_OP_DISP" ;
			reg = <0x10 0x8>;
			desc = "AMO op dispatches in MCS" ;
		};
		event@18 {
			event-name = "PWR_QFULL_NO_DISP" ;
			reg = <0x18 0x8>;
			desc = "Partial Write not dispatched in MCS due to capacity - pulses once for each time a valid WRTO op is not dispatched due to a command list full condition" ;
		};
		event@28 {
			event-name = "64B_RD_DISP" ;
			reg = <0x28 0x8>;
			desc = "Total Read 64-byte data blocks for MCS" ;
		};
		event@30 {
			event-name = "64B_WR_DISP" ;
			reg = <0x30 0x8>;
			desc = "Total Write 64-byte data blocks for MCS" ;
		};
	};
	mcs0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MCS0_";
		unit = "MiB";
		scale = "1.2207e-4";
		reg = <0x118 0x8>;
		events = < &NEST_MCS >;
	};
	mcs1 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MCS1_";
		unit = "MiB";
		scale = "1.2207e-4";
		reg = <0x198 0x8>;
		events = < &NEST_MCS >;
	};
	mcs2 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MCS2_";
		unit = "MiB";
		scale = "1.2207e-4";
		reg = <0x218 0x8>;
		events = < &NEST_MCS >;
	};
	mcs3 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MCS3_";
		unit = "MiB";
		scale = "1.2207e-4";
		reg = <0x298 0x8>;
		events = < &NEST_MCS >;
	};
NEST_POWERBUS: nest-powerbus-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "EVENT_VG_PUMP" ;
			reg = <0x0 0x8>;
			desc = "Vg Scope operation (locally mastered) on port n" ;
		};
		event@8 {
			event-name = "EVENT_LNS_PUMP" ;
			reg = <0x8 0x8>;
			desc = "Local Nodal Scope operation (locally mastered) on port n" ;
		};
		event@10 {
			event-name = "EVENT_RTY_VG_PUMP" ;
			reg = <0x10 0x8>;
			desc = "Retry of a Vg Scope operation (locally mastered) - Retry due to (rty_dropped_rcmd;rty_lpc;rty_other)" ;
		};
		event@18 {
			event-name = "EVENT_RTY_LNS_PUMP" ;
			reg = <0x18 0x8>;
			desc = "Retry of a Nodal Scope operation (locally mastered) - Retry due to (rty_dropped_rcmd;rty_lpc;rty_other;etc.)" ;
		};
		event@28 {
			event-name = "EVENT_INTERNAL_DATA_XFER" ;
			reg = <0x28 0x8>;
			desc = "16x 32B OW Data transfer on a PB horizontal bus" ;
		};
		event@30 {
			event-name = "EVENT_DATA_XFER" ;
			reg = <0x30 0x8>;
			desc = "16x 32B OW Data transfer" ;
		};
		event@38 {
			event-name = "EVENT_EXTERNAL_DATA_XFER_S" ;
			reg = <0x38 0x8>;
			desc = "16x 32B OW Data transfer sent on a PB X/A bus" ;
		};
		event@40 {
			event-name = "EVENT_EXTERNAL_DATA_XFER_R" ;
			reg = <0x40 0x8>;
			desc = "16x 32B OW Data transfer received on a PB X/A bus" ;
		};
	};
	powerbus0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_PB_";
		reg = <0x18 0x8>;
		events = < &NEST_POWERBUS >;
	};
NEST_XLINK: nest-xlink-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "IN_CMD_UTIL" ;
			reg = <0x0 0x8>;
			desc = "cmd utilization - 1 count per 16B used per available cycle" ;
		};
		event@8 {
			event-name = "IN_PRESP_UTIL" ;
			reg = <0x8 0x8>;
			desc = "presp util - 1 count per 16B used per available cycle" ;
		};
		event@10 {
			event-name = "IN_DHDR_DATA_UTIL" ;
			reg = <0x10 0x8>;
			desc = "dhdr+data util - 1 count per 16B used per available cycle" ;
		};
		event@18 {
			event-name = "IN_DATA_COUNT" ;
			reg = <0x18 0x8>;
			desc = "data - event" ;
		};
		event@28 {
			event-name = "OUT_CMD_UTIL" ;
			reg = <0x28 0x8>;
			desc = "cmd utilization - 1 count per 16B used per available cycle" ;
		};
		event@30 {
			event-name = "OUT_PRESP_UTIL" ;
			reg = <0x30 0x8>;
			desc = "presp util - 1 count per 16B used per available cycle" ;
		};
		event@38 {
			event-name = "OUT_DHDR_DATA_UTIL" ;
			reg = <0x38 0x8>;
			desc = "dhdr+data util - 1 count per 16B used per available cycle" ;
		};
		event@40 {
			event-name = "OUT_DATA_COUNT" ;
			reg = <0x40 0x8>;
			desc = "data - event" ;
		};
	};
	xlink0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_XLINK0_";
		reg = <0x518 0x8>;
		events = < &NEST_XLINK >;
	};
	xlink1 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_XLINK1_";
		reg = <0x598 0x8>;
		events = < &NEST_XLINK >;
	};
	xlink2 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_XLINK2_";
		reg = <0x618 0x8>;
		events = < &NEST_XLINK >;
	};
NEST_PHB: nest-phb-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "P2P_CI_STORE_ANY_MMIO_RCVD" ;
			reg = <0x0 0x8>;
			desc = "Peer-to-Peer CI Store for ANY MMIO Space Received (Enhancement pending)" ;
		};
		event@8 {
			event-name = "ANY_DMA_FROM_PCIE" ;
			reg = <0x8 0x8>;
			desc = "DMA (any or read or write) received from the PCIE link" ;
		};
		event@10 {
			event-name = "TCE_MISS_ANY" ;
			reg = <0x10 0x8>;
			desc = "TCE Cache Miss (any)" ;
		};
		event@18 {
			event-name = "CYC_CNT" ;
			reg = <0x18 0x8>;
			desc = "PHB Cycles count" ;
		};
	};
	phb0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_PHB0_";
		reg = <0x818 0x8>;
		events = < &NEST_PHB >;
	};
	phb1 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_PHB1_";
		reg = <0x898 0x8>;
		events = < &NEST_PHB >;
	};
	phb2 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_PHB2_";
		reg = <0x918 0x8>;
		events = < &NEST_PHB >;
	};
NEST_MBA: nest-mba-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "ACT_READ" ;
			reg = <0x0 0x8>;
			desc = "ACT for read in MBA" ;
		};
		event@8 {
			event-name = "ACT_WRITE" ;
			reg = <0x8 0x8>;
			desc = "ACT for write in MBA" ;
		};
		event@10 {
			event-name = "CAS_READ" ;
			reg = <0x10 0x8>;
			desc = "CAS for read in MBA" ;
		};
		event@18 {
			event-name = "CAS_WRITE" ;
			reg = <0x18 0x8>;
			desc = "CAS for write in MBA" ;
		};
		event@28 {
			event-name = "RRQ_FULL" ;
			reg = <0x28 0x8>;
			desc = "RRQ full in MBA" ;
		};
		event@30 {
			event-name = "REF_ALL" ;
			reg = <0x30 0x8>;
			desc = "Total number of Refresh (HP and LP) in MBA" ;
		};
	};
	mba0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MBA0_";
		reg = <0x318 0x8>;
		events = < &NEST_MBA >;
	};
	mba1 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MBA1_";
		reg = <0x398 0x8>;
		events = < &NEST_MBA >;
	};
	mba2 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MBA2_";
		reg = <0x418 0x8>;
		events = < &NEST_MBA >;
	};
	mba3 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MBA3_";
		reg = <0x498 0x8>;
		events = < &NEST_MBA >;
	};
NEST_MCD: nest-mcd-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "SLICE0_RTYDINC" ;
			reg = <0x0 0x8>;
			desc = "A check type command on PowerBus port 0 where a rty_dinc is issued" ;
		};
		event@8 {
			event-name = "SLICE2_RTYDINC" ;
			reg = <0x8 0x8>;
			desc = "check type command on PowerBus port 2 where a rty_dinc is issued" ;
		};
		event@10 {
			event-name = "RECOVERY_SKIP" ;
			reg = <0x10 0x8>;
			desc = "Recovery of a granule/ group vector was skipped because no dirty granules were found data read" ;
		};
		event@18 {
			event-name = "RECOVERY_SET_HIT" ;
			reg = <0x18 0x8>;
			desc = "Set type powerbus command from a vector hit a cache line in the granule(s) being recovered" ;
		};
	};
	mcd0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MCD0_";
		reg = <0x718 0x8>;
		events = < &NEST_MCD >;
	};
	mcd1 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_MCD1_";
		reg = <0x798 0x8>;
		events = < &NEST_MCD >;
	};
NEST_CAPP: nest-capp-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "APC_SN_HIT_APC" ;
			reg = <0x0 0x8>;
			desc = "snoop on either addr pipeline hits an apcfsm" ;
		};
		event@8 {
			event-name = "APC_UOP_SEND_PB_CMD" ;
			reg = <0x8 0x8>;
			desc = "APC uOP command for sending PB Command" ;
		};
		event@10 {
			event-name = "APC_UOP_LCO" ;
			reg = <0x10 0x8>;
			desc = "APC uOP command for LCO" ;
		};
		event@18 {
			event-name = "APC_UOP_DATA_XFER" ;
			reg = <0x18 0x8>;
			desc = "APC uOP command for Data transfer" ;
		};
		event@28 {
			event-name = "XPT_MSG_SENT" ;
			reg = <0x28 0x8>;
			desc = "Message buffer sent due to timer expired and Buffer Threshold not hit" ;
		};
		event@30 {
			event-name = "XPT_MSG_SENT_LE_16" ;
			reg = <0x30 0x8>;
			desc = "Message buffer of tsize less than or equal to 16 bytes sent" ;
		};
		event@38 {
			event-name = "XPT_MSG_SENT_GT_16_LE_64" ;
			reg = <0x38 0x8>;
			desc = "Message buffer of tsize greater than 16 bytes but less than or equal to 64 bytes sent" ;
		};
		event@40 {
			event-name = "XPT_MSG_SENT_GT_64_LE_128" ;
			reg = <0x40 0x8>;
			desc = "Message buffer of tsize greater than 64 bytes but less than or equal to 128 bytes sent" ;
		};
	};
	capp0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_CAPP_";
		reg = <0x998 0x8>;
		events = < &NEST_CAPP >;
	};
NEST_NVLINK: nest-nvlink-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "ATS_TCE_TRANS_REQ" ;
			reg = <0x0 0x8>;
			desc = "TCE Translation Request" ;
		};
		event@8 {
			event-name = "ATS_TCE_MISS" ;
			reg = <0x8 0x8>;
			desc = "TCE Miss" ;
		};
		event@10 {
			event-name = "ATS_NOTRANS_TCE_TRANS" ;
			reg = <0x10 0x8>;
			desc = "No-Translate Mode TCE Translation" ;
		};
		event@18 {
			event-name = "ATS_CACHE_RERUN_MISS" ;
			reg = <0x18 0x8>;
			desc = "TCE Cache Rerun Miss" ;
		};
		event@28 {
			event-name = "ATR_CHECKOUT_D" ;
			reg = <0x28 0x8>;
			desc = "ATR Demand Checkout" ;
		};
		event@30 {
			event-name = "ATR_CHECKOUT_P" ;
			reg = <0x30 0x8>;
			desc = "ATR Prefetch Checkout" ;
		};
		event@38 {
			event-name = "ATR_ATSD_TLBI_RVCD" ;
			reg = <0x38 0x8>;
			desc = "ATSD TLBI Received" ;
		};
		event@40 {
			event-name = "ATR_ATSD_SENT" ;
			reg = <0x40 0x8>;
			desc = "ATSD Sent" ;
		};
		event@80 {
			event-name = "NPCQ0_DWNGRD_REQ0" ;
			reg = <0x80 0x8>;
			desc = "Downgrade Request to Brick 0" ;
		};
		event@88 {
			event-name = "NPCQ0_ATSD_REQ0" ;
			reg = <0x88 0x8>;
			desc = "ATSD Request to Brick 0" ;
		};
		event@90 {
			event-name = "NPCQ0_DWNGRD_REQ1" ;
			reg = <0x90 0x8>;
			desc = "Downgrade Request to Brick 1" ;
		};
		event@98 {
			event-name = "NPCQ0_ATSD_REQ1" ;
			reg = <0x98 0x8>;
			desc = "ATSD Request to Brick 1" ;
		};
		event@a8 {
			event-name = "NPCQ1_DWNGRD_REQ0" ;
			reg = <0xa8 0x8>;
			desc = "Downgrade Request to Brick 0" ;
		};
		event@b0 {
			event-name = "NPCQ1_ATSD_REQ0" ;
			reg = <0xb0 0x8>;
			desc = "ATSD Request to Brick 0" ;
		};
		event@b8 {
			event-name = "NPCQ1_DWNGRD_REQ1" ;
			reg = <0xb8 0x8>;
			desc = "Downgrade Request to Brick 1" ;
		};
		event@c0 {
			event-name = "NPCQ1_ATSD_REQ1" ;
			reg = <0xc0 0x8>;
			desc = "ATSD Request to Brick 1" ;
		};
		event@100 {
			event-name = "NPCQ2_DWNGRD_REQ0" ;
			reg = <0x100 0x8>;
			desc = "Downgrade Request to Brick 0" ;
		};
		event@108 {
			event-name = "NPCQ2_ATSD_REQ0" ;
			reg = <0x108 0x8>;
			desc = "ATSD Request to Brick 0" ;
		};
		event@110 {
			event-name = "NPCQ2_DWNGRD_REQ1" ;
			reg = <0x110 0x8>;
			desc = "Downgrade Request to Brick 1" ;
		};
		event@118 {
			event-name = "NPCQ2_ATSD_REQ1" ;
			reg = <0x118 0x8>;
			desc = "ATSD Request to Brick 1" ;
		};
		event@180 {
			event-name = "NTL1_DATA_FLIT_SENT" ;
			reg = <0x180 0x8>;
			desc = "Data FLIT Sent" ;
		};
		event@188 {
			event-name = "NTL1_PROBE_RESP_DATA" ;
			reg = <0x188 0x8>;
			desc = "Probe Response w/ Data Sent" ;
		};
		event@190 {
			event-name = "NTL1_TRANS_RESP_DATA" ;
			reg = <0x190 0x8>;
			desc = "Transdone Response w/ Data Sent" ;
		};
		event@198 {
			event-name = "NTL1_DATA_FLIT_RCVD" ;
			reg = <0x198 0x8>;
			desc = "Data FLIT Received " ;
		};
		event@1a8 {
			event-name = "NTL2_DATA_FLIT_SENT" ;
			reg = <0x1a8 0x8>;
			desc = "Data FLIT Sent" ;
		};
		event@1b0 {
			event-name = "NTL2_PROBE_RESP_DATA" ;
			reg = <0x1b0 0x8>;
			desc = "Probe Response w/ Data Sent" ;
		};
		event@1b8 {
			event-name = "NTL2_TRANS_RESP_DATA" ;
			reg = <0x1b8 0x8>;
			desc = "Transdone Response w/ Data Sent" ;
		};
		event@1c0 {
			event-name = "NTL2_DATA_FLIT_RCVD" ;
			reg = <0x1c0 0x8>;
			desc = "Data FLIT Received " ;
		};
		event@200 {
			event-name = "NTL3_DATA_FLIT_SENT" ;
			reg = <0x200 0x8>;
			desc = "Data FLIT Sent" ;
		};
		event@208 {
			event-name = "NTL3_PROBE_RESP_DATA" ;
			reg = <0x208 0x8>;
			desc = "Probe Response w/ Data Sent" ;
		};
		event@210 {
			event-name = "NTL3_TRANS_RESP_DATA" ;
			reg = <0x210 0x8>;
			desc = "Transdone Response w/ Data Sent" ;
		};
		event@218 {
			event-name = "NTL3_DATA_FLIT_RCVD" ;
			reg = <0x218 0x8>;
			desc = "Data FLIT Received " ;
		};
		event@228 {
			event-name = "NTL4_DATA_FLIT_SENT" ;
			reg = <0x228 0x8>;
			desc = "Data FLIT Sent" ;
		};
		event@230 {
			event-name = "NTL4_PROBE_RESP_DATA" ;
			reg = <0x230 0x8>;
			desc = "Probe Response w/ Data Sent" ;
		};
		event@238 {
			event-name = "NTL4_TRANS_RESP_DATA" ;
			reg = <0x238 0x8>;
			desc = "Transdone Response w/ Data Sent" ;
		};
		event@240 {
			event-name = "NTL4_DATA_FLIT_RCVD" ;
			reg = <0x240 0x8>;
			desc = "Data FLIT Received " ;
		};
		event@280 {
			event-name = "NTL5_DATA_FLIT_SENT" ;
			reg = <0x280 0x8>;
			desc = "Data FLIT Sent" ;
		};
		event@288 {
			event-name = "NTL5_PROBE_RESP_DATA" ;
			reg = <0x288 0x8>;
			desc = "Probe Response w/ Data Sent" ;
		};
		event@290 {
			event-name = "NTL5_TRANS_RESP_DATA" ;
			reg = <0x290 0x8>;
			desc = "Transdone Response w/ Data Sent" ;
		};
		event@298 {
			event-name = "NTL5_DATA_FLIT_RCVD" ;
			reg = <0x298 0x8>;
			desc = "Data FLIT Received " ;
		};
		event@2a8 {
			event-name = "NTL6_DATA_FLIT_SENT" ;
			reg = <0x2a8 0x8>;
			desc = "Data FLIT Sent" ;
		};
		event@2b0 {
			event-name = "NTL6_PROBE_RESP_DATA" ;
			reg = <0x2b0 0x8>;
			desc = "Probe Response w/ Data Sent" ;
		};
		event@2b8 {
			event-name = "NTL6_TRANS_RESP_DATA" ;
			reg = <0x2b8 0x8>;
			desc = "Transdone Response w/ Data Sent" ;
		};
		event@2c0 {
			event-name = "NTL6_DATA_FLIT_RCVD" ;
			reg = <0x2c0 0x8>;
			desc = "Data FLIT Received " ;
		};
	};
	nvlink0 {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_NPU_";
		reg = <0xa18 0x8>;
		events = < &NEST_NVLINK >;
	};
NEST_NX: nest-nx-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@0 {
			event-name = "ERAT_LOOKUP" ;
			reg = <0x0 0x8>;
			desc = "Number of ERAT lookups" ;
		};
		event@8 {
			event-name = "ERAT_MISS" ;
			reg = <0x8 0x8>;
			desc = "Number of ERAT misses" ;
		};
		event@10 {
			event-name = "ERAT_STALLED_CICO_BUFFERS" ;
			reg = <0x10 0x8>;
			desc = "ERAT stalled due to Checkin/Checkout buffers full" ;
		};
		event@18 {
			event-name = "DMA_STALL" ;
			reg = <0x18 0x8>;
			desc = "number of DMA stalls" ;
		};
		event@28 {
			event-name = "PBI_RD_SENT" ;
			reg = <0x28 0x8>;
			desc = "PBI command to Read from the Write SM sent" ;
		};
		event@30 {
			event-name = "PBI_WR_SENT" ;
			reg = <0x30 0x8>;
			desc = "PBI command to write from the Write SM sent" ;
		};
		event@38 {
			event-name = "PBI_RCV_RETRY01" ;
			reg = <0x38 0x8>;
			desc = "One of the master engines (read" ;
		};
		event@40 {
			event-name = "PBI_RCV_RETRY23" ;
			reg = <0x40 0x8>;
			desc = "One of the master engines (read" ;
		};
	};
	nx {
		compatible = "ibm,imc-counters-nest";
		events-prefix = "PM_NX_";
		reg = <0xd18 0x8>;
		events = < &NEST_NX >;
	};
CORE_THREAD: core-thread-events {
		#address-cells = <0x1>;
		#size-cells = <0x1>;

		event@c8 {
			event-name = "0THRD_NON_IDLE_PCYC" ;
			reg = <0xc8 0x8>;
			desc = "The number of processor cycles when all threads are idle" ;
		};
		event@108 {
			event-name = "1THRD_NON_IDLE_PCYC" ;
			reg = <0x108 0x8>;
			desc = "The number of processor cycles when exactly one SMT thread is executing non-idle code" ;
		};
		event@100 {
			event-name = "1THRD_NON_IDLE_INST" ;
			reg = <0x100 0x8>;
			desc = "The number of PPC instructions completed when exactly one  SMT thread is executing non-idle instructions" ;
		};
		event@148 {
			event-name = "2THRD_NON_IDLE_PCYC" ;
			reg = <0x148 0x8>;
			desc = "The number of processor cycles when exactly two SMT threads are executing non-idle code. The cycles are only counted for threads that execute non-idle code within an LPAR" ;
		};
		event@140 {
			event-name = "2THRD_NON_IDLE_INST" ;
			reg = <0x140 0x8>;
			desc = "The number of PPC instructions completed when exactly two SMT threads are executing non-idle instructions" ;
		};
		event@88 {
			event-name = "32MHZ_CYC" ;
			reg = <0x88 0x8>;
			desc = "The number of constant 32 MHZ clock ticks (Time calibration)" ;
		};
		event@188 {
			event-name = "3THRD_NON_IDLE_PCYC" ;
			reg = <0x188 0x8>;
			desc = "The number of processor cycles when exactly three SMT threads are executing non-idle code. The cycles are only counted for threads that execute non-idle code within an LPAR" ;
		};
		event@180 {
			event-name = "3THRD_NON_IDLE_INST" ;
			reg = <0x180 0x8>;
			desc = "The number of PPC instruction completed when exactly three SMT threads are executing non-idle instructions" ;
		};
		event@1c8 {
			event-name = "4THRD_NON_IDLE_PCYC" ;
			reg = <0x1c8 0x8>;
			desc = "The number of processor cycles when exactly four SMT threads are executing non-idle code. The cycles are only counted for threads that execute non-idle code within an LPAR" ;
		};
		event@1c0 {
			event-name = "4THRD_NON_IDLE_INST" ;
			reg = <0x1c0 0x8>;
			desc = "The number of PPC instructions completed when exactly four SMT threads are executing non-idle instructions" ;
		};
		event@4c0 {
			event-name = "EXT_INT_EBB" ;
			reg = <0x4c0 0x8>;
			desc = "The sum of external event based branch interrupts across all SMT threads (DD2 only)" ;
		};
		event@500 {
			event-name = "EXT_INT_HYP" ;
			reg = <0x500 0x8>;
			desc = "The sum of hypervisor virtualization interrupts across all SMT threads (DD2 only)" ;
		};
		event@9c0 {
			event-name = "CS_DTLB_MISS_2M" ;
			reg = <0x9c0 0x8>;
			desc = "The number of data TLB misses for 2M page size" ;
		};
		event@19c0 {
			event-name = "CS_DTLB_MISS_2M_KERNEL" ;
			reg = <0x19c0 0x8>;
			desc = "The number of data TLB misses for 2M page size in kernel state" ;
		};
		event@11c0 {
			event-name = "CS_DTLB_MISS_2M_USER" ;
			reg = <0x11c0 0x8>;
			desc = "The number of data TLB misses for 2M page size in user state" ;
		};
		event@c0 {
			event-name = "TLB_RELOAD_L2" ;
			reg = <0xc0 0x8>;
			desc = "Radix or HPT reloads found in L2" ;
		};
		event@200 {
			event-name = "TLB_RELOAD_L3" ;
			reg = <0x200 0x8>;
			desc = "Radix or HPT reloads found in L3" ;
		};
		event@240 {
			event-name = "TLB_RELOAD_L3_MISS" ;
			reg = <0x240 0x8>;
			desc = "Radix or HPT reloads found beyond L3" ;
		};
		event@280 {
			event-name = "TM_PASSED" ;
			reg = <0x280 0x8>;
			desc = "Number of TM transactions that passed" ;
		};
		event@2c0 {
			event-name = "TM_ABORTS" ;
			reg = <0x2c0 0x8>;
			desc = "Number of TM transactions aborted" ;
		};
		event@40 {
			event-name = "ANY_THRD_NON_IDLE_PCYC" ;
			reg = <0x40 0x8>;
			desc = "The number of processor cycles when one or more SMT threads is running non-idle instructions" ;
		};
		event@408 {
			event-name = "BUS_PUMP_CHIP_CORRECT_PRED" ;
			reg = <0x408 0x8>;
			desc = "The number of times chip pump was correctly predicted" ;
		};
		event@400 {
			event-name = "BUS_PUMP_GROUP_CORRECT_PRED" ;
			reg = <0x400 0x8>;
			desc = "The number of times group pump was correctly predicted" ;
		};
		event@448 {
			event-name = "BUS_PUMP_GROUP_TOO_LARGE" ;
			reg = <0x448 0x8>;
			desc = "The number of times group pump was predicted where chip pump was sufficient" ;
		};
		event@440 {
			event-name = "BUS_PUMP_GROUP_TOO_SMALL" ;
			reg = <0x440 0x8>;
			desc = "The number of times of incorrectly predicted pump where group pump was needed but a smaller pump was predicted" ;
		};
		event@3c8 {
			event-name = "BUS_PUMP_NON_FABRIC_OP" ;
			reg = <0x3c8 0x8>;
			desc = "The number of time the data source was local Level 2 or Level 3 cache (non fabric)" ;
		};
		event@3c0 {
			event-name = "BUS_PUMP_SYSTEM_CORRECT_PRED" ;
			reg = <0x3c0 0x8>;
			desc = "The number of times system pump was correctly predicted" ;
		};
		event@488 {
			event-name = "BUS_PUMP_SYSTEM_TOO_LARGE" ;
			reg = <0x488 0x8>;
			desc = "The number of times system pump was predicted where node pump was sufficient" ;
		};
		event@480 {
			event-name = "BUS_PUMP_SYSTEM_TOO_SMALL" ;
			reg = <0x480 0x8>;
			desc = "The number of times of incorrectly predicted pump where system pump was needed but a smaller pump was predicted" ;
		};
		event@80 {
			event-name = "CCYC" ;
			reg = <0x80 0x8>;
			desc = "The number of constant clock ticks used for the measurement interval. The clock frequency is constant at 32MHz and is set at CEC power on time" ;
		};
		event@48 {
			event-name = "CORE_ALL_THRD_NON_IDLE_PCYC" ;
			reg = <0x48 0x8>;
			desc = "The number of processor cycles when all threads are executing non-idle instructions" ;
		};
		event@ac0 {
			event-name = "CS_1PLUS_PPC_CMPL" ;
			reg = <0xac0 0x8>;
			desc = "The sum of completed PPC instructions across all SMT threads of the core" ;
		};
		event@1ac0 {
			event-name = "CS_1PLUS_PPC_CMPL_KERNEL" ;
			reg = <0x1ac0 0x8>;
			desc = "The kernel sum of completed PPC instructions across all SMT threads of the core " ;
		};
		event@12c0 {
			event-name = "CS_1PLUS_PPC_CMPL_USER" ;
			reg = <0x12c0 0x8>;
			desc = "The user sum of completed PPC instructions across all SMT threads of the core" ;
		};
		event@8c8 {
			event-name = "CS_32MHZ_CYC" ;
			reg = <0x8c8 0x8>;
			desc = "The number of 32 MHz clock ticks" ;
		};
		event@18c8 {
			event-name = "CS_32MHZ_CYC_KERNEL" ;
			reg = <0x18c8 0x8>;
			desc = "The number of 32 MHz clock ticks in the kernel" ;
		};
		event@10c8 {
			event-name = "CS_32MHZ_CYC_USER" ;
			reg = <0x10c8 0x8>;
			desc = "The number of 32 MHz clock ticks in user space" ;
		};
		event@948 {
			event-name = "CS_BRU_CMPL" ;
			reg = <0x948 0x8>;
			desc = "The number of branch instructions completed" ;
		};
		event@1948 {
			event-name = "CS_BRU_CMPL_KERNEL" ;
			reg = <0x1948 0x8>;
			desc = "The number of branch instructions completed in the kernel" ;
		};
		event@1148 {
			event-name = "CS_BRU_CMPL_USER" ;
			reg = <0x1148 0x8>;
			desc = "The number of branch instructions completed in user space" ;
		};
		event@980 {
			event-name = "CS_BR_MPRED" ;
			reg = <0x980 0x8>;
			desc = "The sum of branch misdirection across all SMT threads of the core" ;
		};
		event@1980 {
			event-name = "CS_BR_MPRED_KERNEL" ;
			reg = <0x1980 0x8>;
			desc = "The sum of branch misdirection across all SMT threads of the core in the kernel" ;
		};
		event@1180 {
			event-name = "CS_BR_MPRED_USER" ;
			reg = <0x1180 0x8>;
			desc = "The sum of branch misdirection across all SMT threads of the core in user space" ;
		};
		event@988 {
			event-name = "CS_BR_TAKEN" ;
			reg = <0x988 0x8>;
			desc = "The number of branches taken" ;
		};
		event@1988 {
			event-name = "CS_BR_TAKEN_KERNEL" ;
			reg = <0x1988 0x8>;
			desc = "The number of branches taken in kernel" ;
		};
		event@1188 {
			event-name = "CS_BR_TAKEN_USER" ;
			reg = <0x1188 0x8>;
			desc = "The number of branches taken in user space" ;
		};
		event@ac8 {
			event-name = "CS_CMPLU_STALL_PCYC" ;
			reg = <0xac8 0x8>;
			desc = "The sum of all processor cycles across all SMT threads where no instruction completed and ICT was not empty" ;
		};
		event@1ac8 {
			event-name = "CS_CMPLU_STALL_PCYC_KERNEL" ;
			reg = <0x1ac8 0x8>;
			desc = "The kernel sum of all processor cycles across all SMT threads where no instruction completed and ICT was not empty" ;
		};
		event@12c8 {
			event-name = "CS_CMPLU_STALL_PCYC_USER" ;
			reg = <0x12c8 0x8>;
			desc = "The user sum of all processor cycles across all SMT threads where no instruction completed and ICT was not empty" ;
		};
		event@848 {
			event-name = "CS_CORE_MODE_SMT2_CCYC" ;
			reg = <0x848 0x8>;
			desc = "The number of constant clock cycles while the core is running in SMT2 mode" ;
		};
		event@1848 {
			event-name = "CS_CORE_MODE_SMT2_CCYC_KERNEL" ;
			reg = <0x1848 0x8>;
			desc = "The number of constant clock cycles in the kernel while the core is running in SMT2 mode" ;
		};
		event@1048 {
			event-name = "CS_CORE_MODE_SMT2_CCYC_USER" ;
			reg = <0x1048 0x8>;
			desc = "The number of constant clock cycles in user state while the core is running in SMT2 mode" ;
		};
		event@880 {
			event-name = "CS_CORE_MODE_SMT4_CCYC" ;
			reg = <0x880 0x8>;
			desc = "Count of constant clock transitions while core mode is SMT4" ;
		};
		event@1880 {
			event-name = "CS_CORE_MODE_SMT4_CCYC_KERNEL" ;
			reg = <0x1880 0x8>;
			desc = "Count of constant clock transitions in kernel state while core mode is SMT4" ;
		};
		event@1080 {
			event-name = "CS_CORE_MODE_SMT4_CCYC_USER" ;
			reg = <0x1080 0x8>;
			desc = "Count of constant clock transitions in user state while core mode is SMT4" ;
		};
		event@2c8 {
			event-name = "L2L3_NODAL_PB_REQ" ;
			reg = <0x2c8 0x8>;
			desc = "The number of Power Bus Requests by Level 2 or Level 3 cache using Nodal (neither X-Bus or A-Bus)" ;
		};
		event@388 {
			event-name = "EXT_INT_DOORBELL" ;
			reg = <0x388 0x8>;
			desc = "The sum of doorbell interrupts across all SMT threads (DD2 only)" ;
		};
		event@4c8 {
			event-name = "THREAD_NAP_STATE_SAVE_CCYC" ;
			reg = <0x4c8 0x8>;
			desc = "The sum of all constant clock cycles across all SMT threads in Power Saving mode where the thread state is saved (DD2 only)" ;
		};
		event@840 {
			event-name = "CS_CORE_MODE_ST_CCYC" ;
			reg = <0x840 0x8>;
			desc = "The number of processor cycles while the core is running in ST mode" ;
		};
		event@1840 {
			event-name = "CS_CORE_MODE_ST_CCYC_KERNEL" ;
			reg = <0x1840 0x8>;
			desc = "The number of processor cycles in the kernel while the core is running in ST mode" ;
		};
		event@1040 {
			event-name = "CS_CORE_MODE_ST_CCYC_USER" ;
			reg = <0x1040 0x8>;
			desc = "The number of processor cycles in the user state while the core is running in ST mode" ;
		};
		event@8c0 {
			event-name = "CS_CORE_PCYC" ;
			reg = <0x8c0 0x8>;
			desc = "The number of processor cycles during the measurement interval" ;
		};
		event@18c0 {
			event-name = "CS_CORE_PCYC_KERNEL" ;
			reg = <0x18c0 0x8>;
			desc = "The number of processor cycles in kernel state during the measurement interval" ;
		};
		event@10c0 {
			event-name = "CS_CORE_PCYC_USER" ;
			reg = <0x10c0 0x8>;
			desc = "The number of processor cycles in user state during the measurement interval" ;
		};
		event@a80 {
			event-name = "CS_DATA_TABLEWALK_PCYC" ;
			reg = <0xa80 0x8>;
			desc = "The sum of table walk processor cycles across all SMT threads of the core" ;
		};
		event@1a80 {
			event-name = "CS_DATA_TABLEWALK_PCYC_KERNEL" ;
			reg = <0x1a80 0x8>;
			desc = "The sum of table walk processor cycles across all SMT threads of the core in kernel state" ;
		};
		event@1280 {
			event-name = "CS_DATA_TABLEWALK_PCYC_USER" ;
			reg = <0x1280 0x8>;
			desc = "The sum of table walk processor cycles across all SMT threads of the core in user state" ;
		};
		event@ec0 {
			event-name = "CS_DERAT_MISS" ;
			reg = <0xec0 0x8>;
			desc = "The number of DERAT misses" ;
		};
		event@1e80 {
			event-name = "CS_DERAT_MISS_KERNEL" ;
			reg = <0x1e80 0x8>;
			desc = "The number of DERAT misses in kernel state" ;
		};
		event@16c0 {
			event-name = "CS_DERAT_MISS_USER" ;
			reg = <0x16c0 0x8>;
			desc = "The number of DERAT misses in user state" ;
		};
		event@a08 {
			event-name = "CS_DISP_HELD_PCYC" ;
			reg = <0xa08 0x8>;
			desc = "The number of processor cycles the dispatch unit was held" ;
		};
		event@1a08 {
			event-name = "CS_DISP_HELD_PCYC_KERNEL" ;
			reg = <0x1a08 0x8>;
			desc = "The number of processor cycles the dispatch unit was held in kernel state" ;
		};
		event@1208 {
			event-name = "CS_DISP_HELD_PCYC_USER" ;
			reg = <0x1208 0x8>;
			desc = "The number of processor cycles the dispatch unit was held in user state" ;
		};
		event@f48 {
			event-name = "CS_DTLB_MISS_16G" ;
			reg = <0xf48 0x8>;
			desc = "The number of data TLB misses for 16G page size" ;
		};
		event@1f08 {
			event-name = "CS_DTLB_MISS_16G_KERNEL" ;
			reg = <0x1f08 0x8>;
			desc = "The number of data TLB misses for 16G page size in kernel state" ;
		};
		event@1748 {
			event-name = "CS_DTLB_MISS_16G_USER" ;
			reg = <0x1748 0x8>;
			desc = "The number of data TLB misses for 16G page size in user state" ;
		};
		event@f40 {
			event-name = "CS_DTLB_MISS_16M" ;
			reg = <0xf40 0x8>;
			desc = "The number of data TLB misses for 16M page size" ;
		};
		event@1f00 {
			event-name = "CS_DTLB_MISS_16M_KERNEL" ;
			reg = <0x1f00 0x8>;
			desc = "The number of data TLB misses for 16M page size in kernel state" ;
		};
		event@1740 {
			event-name = "CS_DTLB_MISS_16M_USER" ;
			reg = <0x1740 0x8>;
			desc = "The number of data TLB misses for 16M page size in user state" ;
		};
		event@f00 {
			event-name = "CS_DTLB_MISS_4K" ;
			reg = <0xf00 0x8>;
			desc = "The number of data TLB misses for 4K page size" ;
		};
		event@1ec0 {
			event-name = "CS_DTLB_MISS_4K_KERNEL" ;
			reg = <0x1ec0 0x8>;
			desc = "The number of data TLB misses for 4K page size in kernel state" ;
		};
		event@1700 {
			event-name = "CS_DTLB_MISS_4K_USER" ;
			reg = <0x1700 0x8>;
			desc = "The number of data TLB misses for 4K page size in user state" ;
		};
		event@f08 {
			event-name = "CS_DTLB_MISS_64K" ;
			reg = <0xf08 0x8>;
			desc = "The number of data TLB misses for 64K page size" ;
		};
		event@1ec8 {
			event-name = "CS_DTLB_MISS_64K_KERNEL" ;
			reg = <0x1ec8 0x8>;
			desc = "The number of data TLB misses for 64K page size in kernel state" ;
		};
		event@1708 {
			event-name = "CS_DTLB_MISS_64K_USER" ;
			reg = <0x1708 0x8>;
			desc = "The number of data TLB misses for 64K page size in user state" ;
		};
		event@ec8 {
			event-name = "CS_DTLB_RELOAD" ;
			reg = <0xec8 0x8>;
			desc = "The number of data TLB reloads" ;
		};
		event@1e88 {
			event-name = "CS_DTLB_RELOAD_KERNEL" ;
			reg = <0x1e88 0x8>;
			desc = "The number of data TLB reloads in kernel state" ;
		};
		event@16c8 {
			event-name = "CS_DTLB_RELOAD_USER" ;
			reg = <0x16c8 0x8>;
			desc = "The number of data TLB reloads in user state" ;
		};
		event@940 {
			event-name = "CS_FLOP" ;
			reg = <0x940 0x8>;
			desc = "The number of all completed floating point operations" ;
		};
		event@1940 {
			event-name = "CS_FLOP_KERNEL" ;
			reg = <0x1940 0x8>;
			desc = "The number of all completed floating point operations in kernel state" ;
		};
		event@1140 {
			event-name = "CS_FLOP_USER" ;
			reg = <0x1140 0x8>;
			desc = "The number of all completed floating point operations in user state" ;
		};
		event@a88 {
			event-name = "CS_FLUSH" ;
			reg = <0xa88 0x8>;
			desc = "The number of core flushes" ;
		};
		event@1a88 {
			event-name = "CS_FLUSH_KERNEL" ;
			reg = <0x1a88 0x8>;
			desc = "The number of core flushes in the kernel state" ;
		};
		event@1288 {
			event-name = "CS_FLUSH_USER" ;
			reg = <0x1288 0x8>;
			desc = "The number of core flushes in the user state" ;
		};
		event@b40 {
			event-name = "CS_FROM_L2_IFETCH" ;
			reg = <0xb40 0x8>;
			desc = "The number of instruction fetches from local level 2 cache" ;
		};
		event@1b40 {
			event-name = "CS_FROM_L2_IFETCH_KERNEL" ;
			reg = <0x1b40 0x8>;
			desc = "The number of instruction fetches from local level 2 cache in kernel state" ;
		};
		event@1340 {
			event-name = "CS_FROM_L2_IFETCH_USER" ;
			reg = <0x1340 0x8>;
			desc = "The number of instruction fetches from local level 2 cache in user state" ;
		};
		event@c08 {
			event-name = "CS_FROM_L2_L3_A_IFETCH" ;
			reg = <0xc08 0x8>;
			desc = "The number of instruction fetches from level 2 or level 3 across A-link" ;
		};
		event@1c08 {
			event-name = "CS_FROM_L2_L3_A_IFETCH_KERNEL" ;
			reg = <0x1c08 0x8>;
			desc = "The number of instruction fetches from level 2 or level 3 across A-link in kernel state" ;
		};
		event@1408 {
			event-name = "CS_FROM_L2_L3_A_IFETCH_USER" ;
			reg = <0x1408 0x8>;
			desc = "The number of instruction fetches from level 2 or level 3 across A-link in user state" ;
		};
		event@d88 {
			event-name = "CS_FROM_L2_L3_A_LDATA" ;
			reg = <0xd88 0x8>;
			desc = "The number of data loads from level 2 or level 3 cache through A-link" ;
		};
		event@1d48 {
			event-name = "CS_FROM_L2_L3_A_LDATA_KERNEL" ;
			reg = <0x1d48 0x8>;
			desc = "The number of data loads from level 2 or level 3 cache through A-link in kernel state" ;
		};
		event@1588 {
			event-name = "CS_FROM_L2_L3_A_LDATA_USER" ;
			reg = <0x1588 0x8>;
			desc = "The number of data loads from level 2 or level 3 cache through A-link in user state" ;
		};
		event@c00 {
			event-name = "CS_FROM_L2_L3_X_IFETCH" ;
			reg = <0xc00 0x8>;
			desc = "The number of instruction fetches from level 2 or level 3 cache across X-link" ;
		};
		event@1c00 {
			event-name = "CS_FROM_L2_L3_X_IFETCH_KERNEL" ;
			reg = <0x1c00 0x8>;
			desc = "The number of instruction fetches from level 2 or level 3 cache across X-link in kernel state" ;
		};
		event@1400 {
			event-name = "CS_FROM_L2_L3_X_IFETCH_USER" ;
			reg = <0x1400 0x8>;
			desc = "The number of instruction fetches from level 2 or level 3 cache across X-link in user state" ;
		};
		event@d80 {
			event-name = "CS_FROM_L2_L3_X_LDATA" ;
			reg = <0xd80 0x8>;
			desc = "The number of data loads from a level 2 or level 3 cache across X-link" ;
		};
		event@1d40 {
			event-name = "CS_FROM_L2_L3_X_LDATA_KERNEL" ;
			reg = <0x1d40 0x8>;
			desc = "The number of data loads from a level 2 or level 3 cache across X-link in kernel state" ;
		};
		event@1580 {
			event-name = "CS_FROM_L2_L3_X_LDATA_USER" ;
			reg = <0x1580 0x8>;
			desc = "The number of data loads from a level 2 or level 3 cache across X-link in user state" ;
		};
		event@cc0 {
			event-name = "CS_FROM_L2_LDATA" ;
			reg = <0xcc0 0x8>;
			desc = "The number of local level 2 data loads" ;
		};
		event@1cc0 {
			event-name = "CS_FROM_L2_LDATA_KERNEL" ;
			reg = <0x1cc0 0x8>;
			desc = "The number of local level 2 data loads in kernel state" ;
		};
		event@14c0 {
			event-name = "CS_FROM_L2_LDATA_USER" ;
			reg = <0x14c0 0x8>;
			desc = "The number of local level 2 data loads in user state" ;
		};
		event@b48 {
			event-name = "CS_FROM_L3_IFETCH" ;
			reg = <0xb48 0x8>;
			desc = "The number of instruction fetches from the cores level 3 cache" ;
		};
		event@1b48 {
			event-name = "CS_FROM_L3_IFETCH_KERNEL" ;
			reg = <0x1b48 0x8>;
			desc = "The number of instruction fetches from the cores level 3 cache in kernel state" ;
		};
		event@1348 {
			event-name = "CS_FROM_L3_IFETCH_USER" ;
			reg = <0x1348 0x8>;
			desc = "The number of instruction fetches from the cores level 3 cache in user state" ;
		};
		event@cc8 {
			event-name = "CS_FROM_L3_LDATA" ;
			reg = <0xcc8 0x8>;
			desc = "The number of data loads from the cores level 3 cache" ;
		};
		event@1cc8 {
			event-name = "CS_FROM_L3_LDATA_KERNEL" ;
			reg = <0x1cc8 0x8>;
			desc = "The number of data loads from the cores level 3 cache in kernel state" ;
		};
		event@14c8 {
			event-name = "CS_FROM_L3_LDATA_USER" ;
			reg = <0x14c8 0x8>;
			desc = "The number of data loads from the cores level 3 cache in user state" ;
		};
		event@bc0 {
			event-name = "CS_FROM_L4_IFETCH" ;
			reg = <0xbc0 0x8>;
			desc = "The number of instruction fetches from local level 4 cache" ;
		};
		event@1bc0 {
			event-name = "CS_FROM_L4_IFETCH_KERNEL" ;
			reg = <0x1bc0 0x8>;
			desc = "The number of instruction fetches from local level 4 cache in kernel state" ;
		};
		event@13c0 {
			event-name = "CS_FROM_L4_IFETCH_USER" ;
			reg = <0x13c0 0x8>;
			desc = "The number of instruction fetches from local level 4 cache in user state" ;
		};
		event@d40 {
			event-name = "CS_FROM_L4_LDATA" ;
			reg = <0xd40 0x8>;
			desc = "The number of level 4 data loads from local level 4 cache" ;
		};
		event@1248 {
			event-name = "CS_CORE_ICT_EMPTY_PCYC_USER" ;
			reg = <0x1248 0x8>;
			desc = "The number of processor cycles the ICT was empty in user state" ;
		};
		event@1540 {
			event-name = "CS_FROM_L4_LDATA_USER" ;
			reg = <0x1540 0x8>;
			desc = "The number of level 4 data loads from local level 4 cache in user state" ;
		};
		event@f88 {
			event-name = "CS_FROM_L4_MEM_A_DPTEG" ;
			reg = <0xf88 0x8>;
			desc = "The number of data PTEG misses that are satisfied from level 4 cache of memory across A-link" ;
		};
		event@1f48 {
			event-name = "CS_FROM_L4_MEM_A_DPTEG_KERNEL" ;
			reg = <0x1f48 0x8>;
			desc = "The number of data PTEG misses that are satisfied from level 4 cache of memory across A-link in kernel state" ;
		};
		event@1788 {
			event-name = "CS_FROM_L4_MEM_A_DPTEG_USER" ;
			reg = <0x1788 0x8>;
			desc = "The number of data PTEG misses that are satisfied from level 4 cache of memory across A-link in user state" ;
		};
		event@c48 {
			event-name = "CS_FROM_L4_MEM_A_IFETCH" ;
			reg = <0xc48 0x8>;
			desc = "The number of instruction fetches from level 4 cache or memory across A-link" ;
		};
		event@1c48 {
			event-name = "CS_FROM_L4_MEM_A_IFETCH_KERNEL" ;
			reg = <0x1c48 0x8>;
			desc = "The number of instruction fetches from level 4 cache or memory across A-link in kernel state" ;
		};
		event@1448 {
			event-name = "CS_FROM_L4_MEM_A_IFETCH_USER" ;
			reg = <0x1448 0x8>;
			desc = "The number of instruction fetches from level 4 cache or memory across A-link in user state" ;
		};
		event@e88 {
			event-name = "CS_FROM_L4_MEM_A_IPTEG" ;
			reg = <0xe88 0x8>;
			desc = "The number of instruction PTEG misses that are satisfied from level 4 cache of memory across A-link" ;
		};
		event@1e48 {
			event-name = "CS_FROM_L4_MEM_A_IPTEG_KERNEL" ;
			reg = <0x1e48 0x8>;
			desc = "The number of instruction PTEG misses that are satisfied from level 4 cache of memory across A-link in kernel state" ;
		};
		event@1688 {
			event-name = "CS_FROM_L4_MEM_A_IPTEG_USER" ;
			reg = <0x1688 0x8>;
			desc = "The number of instruction PTEG misses that are satisfied from level 4 cache of memory across A-link in user state" ;
		};
		event@dc8 {
			event-name = "CS_FROM_L4_MEM_A_LDATA" ;
			reg = <0xdc8 0x8>;
			desc = "The number of data loads from level 4 cache or memory across A-link" ;
		};
		event@1d88 {
			event-name = "CS_FROM_L4_MEM_A_LDATA_KERNEL" ;
			reg = <0x1d88 0x8>;
			desc = "The number of data loads from level 4 cache or memory across A-link in kernel state" ;
		};
		event@15c8 {
			event-name = "CS_FROM_L4_MEM_A_LDATA_USER" ;
			reg = <0x15c8 0x8>;
			desc = "The number of data loads from level 4 cache or memory across A-link in user state" ;
		};
		event@f80 {
			event-name = "CS_FROM_L4_MEM_X_DPTEG" ;
			reg = <0xf80 0x8>;
			desc = "The number of instruction PTEG L3 misses that are satisfied by off-chip but node-local source" ;
		};
		event@1f40 {
			event-name = "CS_FROM_L4_MEM_X_DPTEG_KERNEL" ;
			reg = <0x1f40 0x8>;
			desc = "The number of instruction PTEG L3 misses that are satisfied by off-chip but node-local source in kernel state" ;
		};
		event@1780 {
			event-name = "CS_FROM_L4_MEM_X_DPTEG_USER" ;
			reg = <0x1780 0x8>;
			desc = "The number of instruction PTEG L3 misses that are satisfied by off-chip but node-local source in user state" ;
		};
		event@c40 {
			event-name = "CS_FROM_L4_MEM_X_IFETCH" ;
			reg = <0xc40 0x8>;
			desc = "The number of instruction fetches from a level 4 cache or memory across X-link" ;
		};
		event@1c40 {
			event-name = "CS_FROM_L4_MEM_X_IFETCH_KERNEL" ;
			reg = <0x1c40 0x8>;
			desc = "The number of instruction fetches from a level 4 cache or memory across X-link in kernel state" ;
		};
		event@1440 {
			event-name = "CS_FROM_L4_MEM_X_IFETCH_USER" ;
			reg = <0x1440 0x8>;
			desc = "The number of instruction fetches from a level 4 cache or memory across X-link in user state" ;
		};
		event@e80 {
			event-name = "CS_FROM_L4_MEM_X_IPTEG" ;
			reg = <0xe80 0x8>;
			desc = "The number of instruction PTEG L3 misses that are satisfied by off-chip- but node-local source" ;
		};
		event@1e40 {
			event-name = "CS_FROM_L4_MEM_X_IPTEG_KERNEL" ;
			reg = <0x1e40 0x8>;
			desc = "The number of instruction PTEG L3 misses that are satisfied by off-chip- but node-local source in kernel state" ;
		};
		event@1680 {
			event-name = "CS_FROM_L4_MEM_X_IPTEG_USER" ;
			reg = <0x1680 0x8>;
			desc = "The number of instruction PTEG L3 misses that are satisfied by off-chip- but node-local source in user state" ;
		};
		event@dc0 {
			event-name = "CS_FROM_L4_MEM_X_LDATA" ;
			reg = <0xdc0 0x8>;
			desc = "The number of data load from a level 4 cache or memory across X-link" ;
		};
		event@1d80 {
			event-name = "CS_FROM_L4_MEM_X_LDATA_KERNEL" ;
			reg = <0x1d80 0x8>;
			desc = "The number of data load from a level 4 cache or memory across X-link in kernel state" ;
		};
		event@15c0 {
			event-name = "CS_FROM_L4_MEM_X_LDATA_USER" ;
			reg = <0x15c0 0x8>;
			desc = "The number of data load from a level 4 cache or memory across X-link in user state" ;
		};
		event@bc8 {
			event-name = "CS_FROM_MEM_IFETCH" ;
			reg = <0xbc8 0x8>;
			desc = "The number of instruction fetches from local memory" ;
		};
		event@1bc8 {
			event-name = "CS_FROM_MEM_IFETCH_KERNEL" ;
			reg = <0x1bc8 0x8>;
			desc = "The number of instruction fetches from local memory in kernel state" ;
		};
		event@13c8 {
			event-name = "CS_FROM_MEM_IFETCH_USER" ;
			reg = <0x13c8 0x8>;
			desc = "The number of instruction fetches from local memory in user state" ;
		};
		event@d48 {
			event-name = "CS_FROM_MEM_LDATA" ;
			reg = <0xd48 0x8>;
			desc = "The number of data loads from local memory" ;
		};
		event@340 {
			event-name = "TLBIE" ;
			reg = <0x340 0x8>;
			desc = "The number of TLBIE instructions that finished" ;
		};
		event@1548 {
			event-name = "CS_FROM_MEM_LDATA_USER" ;
			reg = <0x1548 0x8>;
			desc = "The number of data loads from local memory in user state" ;
		};
		event@fc8 {
			event-name = "CS_FROM_MEM_LOCAL" ;
			reg = <0xfc8 0x8>;
			desc = "The number of data and instruction misses that are satisfied by local memory" ;
		};
		event@1f88 {
			event-name = "CS_FROM_MEM_LOCAL_KERNEL" ;
			reg = <0x1f88 0x8>;
			desc = "The number of data and instruction misses that are satisfied by local memory in kernel state" ;
		};
		event@17c8 {
			event-name = "CS_FROM_MEM_LOCAL_USER" ;
			reg = <0x17c8 0x8>;
			desc = "The number of data and instruction misses that are satisfied by local memory in user state" ;
		};
		event@fc0 {
			event-name = "CS_FROM_MEM_NON_LOCAL" ;
			reg = <0xfc0 0x8>;
			desc = "The number of all data and instruction cache misses that are satisfied by Off-Chip Memory" ;
		};
		event@1fc0 {
			event-name = "CS_FROM_MEM_NON_LOCAL_KERNEL" ;
			reg = <0x1fc0 0x8>;
			desc = "The number of all data and instruction cache misses that are satisfied by Off-Chip Memory in kernel state" ;
		};
		event@17c0 {
			event-name = "CS_FROM_MEM_NON_LOCAL_USER" ;
			reg = <0x17c0 0x8>;
			desc = "The number of all data and instruction cache misses that are satisfied by Off-Chip Memory in user state" ;
		};
		event@b80 {
			event-name = "CS_FROM_ON_CHIP_L2_IFETCH" ;
			reg = <0xb80 0x8>;
			desc = "The number of instruction fetches from a level 2 cache from the same POWER9 chip" ;
		};
		event@1b80 {
			event-name = "CS_FROM_ON_CHIP_L2_IFETCH_KERNEL" ;
			reg = <0x1b80 0x8>;
			desc = "The number of instruction fetches from a level 2 cache from the same POWER9 chip in kernel state" ;
		};
		event@1380 {
			event-name = "CS_FROM_ON_CHIP_L2_IFETCH_USER" ;
			reg = <0x1380 0x8>;
			desc = "The number of instruction fetches from a level 2 cache from the same POWER9 chip in user state" ;
		};
		event@d00 {
			event-name = "CS_FROM_ON_CHIP_L2_LDATA" ;
			reg = <0xd00 0x8>;
			desc = "The number of data loads from a level 2 cache from the same POWER9 chip" ;
		};
		event@1d00 {
			event-name = "CS_FROM_ON_CHIP_L2_LDATA_KERNEL" ;
			reg = <0x1d00 0x8>;
			desc = "The number of data loads from a level 2 cache from the same POWER9 chip in kernel state" ;
		};
		event@1500 {
			event-name = "CS_FROM_ON_CHIP_L2_LDATA_USER" ;
			reg = <0x1500 0x8>;
			desc = "The number of data loads from a level 2 cache from the same POWER9 chip in user state" ;
		};
		event@b88 {
			event-name = "CS_FROM_ON_CHIP_L3_IFETCH" ;
			reg = <0xb88 0x8>;
			desc = "The number of instruction fetches from level 3 cache on the same POWER9 chip" ;
		};
		event@1b88 {
			event-name = "CS_FROM_ON_CHIP_L3_IFETCH_KERNEL" ;
			reg = <0x1b88 0x8>;
			desc = "The number of instruction fetches from level 3 cache on the same POWER9 chip in kernel state" ;
		};
		event@1388 {
			event-name = "CS_FROM_ON_CHIP_L3_IFETCH_USER" ;
			reg = <0x1388 0x8>;
			desc = "The number of instruction fetches from level 3 cache on the same POWER9 chip in user state" ;
		};
		event@d08 {
			event-name = "CS_FROM_ON_CHIP_L3_LDATA" ;
			reg = <0xd08 0x8>;
			desc = "The number of data loads from a level 3 cache from the same POWER9 chip" ;
		};
		event@1d08 {
			event-name = "CS_FROM_ON_CHIP_L3_LDATA_KERNEL" ;
			reg = <0x1d08 0x8>;
			desc = "The number of data loads from a level 3 cache from the same POWER9 chip in kernel state" ;
		};
		event@1508 {
			event-name = "CS_FROM_ON_CHIP_L3_LDATA_USER" ;
			reg = <0x1508 0x8>;
			desc = "The number of data loads from a level 3 cache from the same POWER9 chip in user state" ;
		};
		event@508 {
			event-name = "L2L3_GROUP_PB_REQ" ;
			reg = <0x508 0x8>;
			desc = "The number of times Level 2 or Level 3 cache made a bus request using the group bus (X-Bus)" ;
		};
		event@5c8 {
			event-name = "L2L3_SYS_PB_REQ" ;
			reg = <0x5c8 0x8>;
			desc = "The number of times the Level 2 or Level 3 cache made a request using the system bus (A-Bus)" ;
		};
		event@608 {
			event-name = "MSR_PRIV_PCYC" ;
			reg = <0x608 0x8>;
			desc = "The number of processor cycles in privileged mode with MSR HV=0 & PR=0" ;
		};
		event@e08 {
			event-name = "CS_CPM_CS_ST_FIN" ;
			reg = <0xe08 0x8>;
			desc = "The number of all store instructions finished" ;
		};
		event@1dc8 {
			event-name = "CS_CPM_CS_ST_FIN_KERNEL" ;
			reg = <0x1dc8 0x8>;
			desc = "The number of all store instructions finished in kernel state" ;
		};
		event@1608 {
			event-name = "CS_CPM_CS_ST_FIN_USER" ;
			reg = <0x1608 0x8>;
			desc = "The number of all store instructions finished in user state" ;
		};
		event@c80 {
			event-name = "CS_CPM_MISS_L1_LDATA" ;
			reg = <0xc80 0x8>;
			desc = "The number of level 1 data misses" ;
		};
		event@1c80 {
			event-name = "CS_CPM_MISS_L1_LDATA_KERNEL" ;
			reg = <0x1c80 0x8>;
			desc = "The number of level 1 data misses in kernel state" ;
		};
		event@1480 {
			event-name = "CS_CPM_MISS_L1_LDATA_USER" ;
			reg = <0x1480 0x8>;
			desc = "The number of level 1 data misses in user state" ;
		};
		event@e40 {
			event-name = "CS_IERAT_MISS" ;
			reg = <0xe40 0x8>;
			desc = "The number of IERAT reloads" ;
		};
		event@1e00 {
			event-name = "CS_IERAT_MISS_KERNEL" ;
			reg = <0x1e00 0x8>;
			desc = "The number of IERAT reloads in kernel state" ;
		};
		event@1640 {
			event-name = "CS_IERAT_MISS_USER" ;
			reg = <0x1640 0x8>;
			desc = "The number of IERAT reloads in user state" ;
		};
		event@b08 {
			event-name = "CS_IFETCH_DEMAND_PCYC" ;
			reg = <0xb08 0x8>;
			desc = "The sum of all processor cycles across all SMT threads when a demand ifetch was pending" ;
		};
		event@1b08 {
			event-name = "CS_IFETCH_DEMAND_PCYC_KERNEL" ;
			reg = <0x1b08 0x8>;
			desc = "The sum of all processor cycles across all SMT threads when a demand ifetch was pending in kernel state" ;
		};
		event@1308 {
			event-name = "CS_IFETCH_DEMAND_PCYC_USER" ;
			reg = <0x1308 0x8>;
			desc = "The sum of all processor cycles across all SMT threads when a demand ifetch was pending in user state" ;
		};
		event@808 {
			event-name = "CS_INST" ;
			reg = <0x808 0x8>;
			desc = "The sum of all completed PPC instructions across all SMT threads of the core" ;
		};
		event@1808 {
			event-name = "CS_INST_KERNEL" ;
			reg = <0x1808 0x8>;
			desc = "The sum of all completed PPC instructions across all SMT threads of the core in kernel state" ;
		};
		event@1008 {
			event-name = "CS_INST_USER" ;
			reg = <0x1008 0x8>;
			desc = "The sum of all completed PPC instructions across all SMT threads of the core in user state" ;
		};
		event@e48 {
			event-name = "CS_ITLB_RELOAD" ;
			reg = <0xe48 0x8>;
			desc = "The number of instruction TLB reloads" ;
		};
		event@1e08 {
			event-name = "CS_ITLB_RELOAD_KERNEL" ;
			reg = <0x1e08 0x8>;
			desc = "The number of instruction TLB reloads in kernel state" ;
		};
		event@1648 {
			event-name = "CS_ITLB_RELOAD_USER" ;
			reg = <0x1648 0x8>;
			desc = "The number of instruction TLB reloads in user state" ;
		};
		event@b00 {
			event-name = "CS_L1_MISS_IFETCH" ;
			reg = <0xb00 0x8>;
			desc = "The number of level 1 instruction misses" ;
		};
		event@1b00 {
			event-name = "CS_L1_MISS_IFETCH_KERNEL" ;
			reg = <0x1b00 0x8>;
			desc = "The number of level 1 instruction misses in kernel state" ;
		};
		event@1300 {
			event-name = "CS_L1_MISS_IFETCH_USER" ;
			reg = <0x1300 0x8>;
			desc = "The number of level 1 instruction misses in user state" ;
		};
		event@a40 {
			event-name = "CS_LSU_EMPTY_PCYC" ;
			reg = <0xa40 0x8>;
			desc = "The sum of processor cycles where the LSU is empty across all SMT threads of the core" ;
		};
		event@1a40 {
			event-name = "CS_LSU_EMPTY_PCYC_KERNEL" ;
			reg = <0x1a40 0x8>;
			desc = "The sum of processor cycles where the LSU is empty across all SMT threads of the core in kernel state" ;
		};
		event@1240 {
			event-name = "CS_LSU_EMPTY_PCYC_USER" ;
			reg = <0x1240 0x8>;
			desc = "The sum of processor cycles where the LSU is empty across all SMT threads of the core in user state" ;
		};
		event@800 {
			event-name = "CS_PCYC" ;
			reg = <0x800 0x8>;
			desc = "The sum of all processor cycles across all SMT threads" ;
		};
		event@1800 {
			event-name = "CS_PCYC_KERNEL" ;
			reg = <0x1800 0x8>;
			desc = "The sum of all processor cycles across all SMT threads in kernel state" ;
		};
		event@1000 {
			event-name = "CS_PCYC_USER" ;
			reg = <0x1000 0x8>;
			desc = "The sum of all processor cycles across all SMT threads in user state" ;
		};
		event@a00 {
			event-name = "CS_PPC_DISP" ;
			reg = <0xa00 0x8>;
			desc = "The sum of PPC instruction dispatches across all SMT threads of the core" ;
		};
		event@1a00 {
			event-name = "CS_PPC_DISP_KERNEL" ;
			reg = <0x1a00 0x8>;
			desc = "The sum of PPC instruction dispatches across all SMT threads of the core in kernel state" ;
		};
		event@1200 {
			event-name = "CS_PPC_DISP_USER" ;
			reg = <0x1200 0x8>;
			desc = "The sum of PPC instruction dispatches across all SMT threads of the core in user state" ;
		};
		event@908 {
			event-name = "CS_PURR" ;
			reg = <0x908 0x8>;
			desc = "The sum of all constant clock PURR increments across all SMT threads" ;
		};
		event@1908 {
			event-name = "CS_PURR_KERNEL" ;
			reg = <0x1908 0x8>;
			desc = "The sum of all constant clock PURR increments across all SMT threads in kernel state" ;
		};
		event@1108 {
			event-name = "CS_PURR_USER" ;
			reg = <0x1108 0x8>;
			desc = "The sum of all constant clock PURR increments across all SMT threads in user state" ;
		};
		event@900 {
			event-name = "CS_SPURR" ;
			reg = <0x900 0x8>;
			desc = "The number of SPURR cycles" ;
		};
		event@1900 {
			event-name = "CS_SPURR_KERNEL" ;
			reg = <0x1900 0x8>;
			desc = "The number of SPURR cycles in kernel state" ;
		};
		event@1100 {
			event-name = "CS_SPURR_USER" ;
			reg = <0x1100 0x8>;
			desc = "The number of SPURR cycles in user state" ;
		};
		event@e00 {
			event-name = "CS_ST_MISS_L1" ;
			reg = <0xe00 0x8>;
			desc = "The number of stores that missed level 1 cache" ;
		};
		event@1dc0 {
			event-name = "CS_ST_MISS_L1_KERNEL" ;
			reg = <0x1dc0 0x8>;
			desc = "The number of stores that missed level 1 cache in kernel state" ;
		};
		event@1600 {
			event-name = "CS_ST_MISS_L1_USER" ;
			reg = <0x1600 0x8>;
			desc = "The number of stores that missed level 1 cache in user state" ;
		};
		event@540 {
			event-name = "EXT_INT_OS" ;
			reg = <0x540 0x8>;
			desc = "The sum of operating system external interrupts across all SMT threads (DD2 only). The sum of external interrupts across all SMT threads (DD1). The event name is for DD2. On DD1 the event is called CPM_EXT_INT" ;
		};
		event@8 {
			event-name = "INST" ;
			reg = <0x8 0x8>;
			desc = "The sum of instructions completed across all SMT threads of the core" ;
		};
		event@348 {
			event-name = "LARX_FIN" ;
			reg = <0x348 0x8>;
			desc = "The sum of all atomic loads (LARX instructions) across all SMT threads that finished" ;
		};
		event@7c0 {
			event-name = "LWSYNC_PCYC" ;
			reg = <0x7c0 0x8>;
			desc = "The number of processor cycles stalled while waiting for a LWSYNC operation to complete (DD2 only)" ;
		};
		event@688 {
			event-name = "MSR_HV_PCYC" ;
			reg = <0x688 0x8>;
			desc = "The number of processor cycles in Hypervisor mode with MSR HV=1 & PR=0" ;
		};
		event@6c8 {
			event-name = "MSR_ADJUNCT_PCYC" ;
			reg = <0x6c8 0x8>;
			desc = "The number of processor cycles with MSR HV=1 & PR=1 (adjunct)" ;
		};
		event@6c0 {
			event-name = "MSR_AJUNCT_INST" ;
			reg = <0x6c0 0x8>;
			desc = "The number of non-idle instructions completed with MSR HV=1 & PR=1 (adjunct)" ;
		};
		event@548 {
			event-name = "MSR_EXT_INT_DIS_CCYC" ;
			reg = <0x548 0x8>;
			desc = "The sum of all processor cycles across all SMT threads with external interrupts disabled (MSR EE=0)" ;
		};
		event@680 {
			event-name = "MSR_HV_INST" ;
			reg = <0x680 0x8>;
			desc = "The number of non-idle instructions in Hypervisor mode with MSR HV=1 & PR=0" ;
		};
		event@600 {
			event-name = "MSR_PRIV_INST" ;
			reg = <0x600 0x8>;
			desc = "The number of non-idle instructions completed in privileged mode with MSR HV=0 & PR=0" ;
		};
		event@648 {
			event-name = "MSR_PROB_PCYC" ;
			reg = <0x648 0x8>;
			desc = "The number of processor cycles in problem mode with MSR HV=0 & PR=1" ;
		};
		event@640 {
			event-name = "MSR_PROB_INST" ;
			reg = <0x640 0x8>;
			desc = "The number of non-idle instructions completed in problem state with MSR HV=0 & PR=1" ;
		};
		event@888 {
			event-name = "SMT_MODE_SWITCH" ;
			reg = <0x888 0x8>;
			desc = "The number of SMT mode switches during the measurement period (DD2 only)" ;
		};
		event@708 {
			event-name = "MSR_TA_LIC_PCYC" ;
			reg = <0x708 0x8>;
			desc = "The number of processor cycles in Tags Active LIC state (MSR US=0 & PR=0)" ;
		};
		event@700 {
			event-name = "MSR_TA_LIC_INST" ;
			reg = <0x700 0x8>;
			desc = "The number of non-idle instructions completed with MSR US=0 & PR=0" ;
		};
		event@740 {
			event-name = "MSR_TA_SYSTEM_INST" ;
			reg = <0x740 0x8>;
			desc = "The number of non-idle instructions completed with MSR US=0 & PR=1" ;
		};
		event@1888 {
			event-name = "SMT_MODE_SWITCH_KERNEL" ;
			reg = <0x1888 0x8>;
			desc = "The number of SMT mode switches during the measurement period in kernel state(DD2 only)" ;
		};
		event@748 {
			event-name = "MSR_TA_SYS_PCYC" ;
			reg = <0x748 0x8>;
			desc = "The number of processor cycles Tags-Active system State (MSR US=0 & PR=1)" ;
		};
		event@788 {
			event-name = "MSR_TA_USER_PCYC" ;
			reg = <0x788 0x8>;
			desc = "The number of processor cycles in Tags-Active user State (MSR US=1 & PR=1)" ;
		};
		event@780 {
			event-name = "MSR_TA_USER_INST" ;
			reg = <0x780 0x8>;
			desc = "The number of non-idle instructions completed with MSR US=1 & PR=1" ;
		};
		event@1088 {
			event-name = "SMT_MODE_SWITCH_USER" ;
			reg = <0x1088 0x8>;
			desc = "The number of SMT mode switches during the measurement period in user state(DD2 only)" ;
		};
		event@588 {
			event-name = "MSR_TRANSMEM_PCYC" ;
			reg = <0x588 0x8>;
			desc = "The sum of all processor cycles across all SMT threads in transactional memory mode with MSR TR=1" ;
		};
		event@580 {
			event-name = "MSR_TRANSMEM_INST" ;
			reg = <0x580 0x8>;
			desc = "The number of PPC instructions completed while the core was in transactional memory mode" ;
		};
		event@0 {
			event-name = "PCYC" ;
			reg = <0x0 0x8>;
			desc = "The sum of processor cycles across all SMT threads of the core. Example, a 3GHz core with 4 SMT threads will report 12 billion processor cycles. Processor clock may vary dynamically" ;
		};
		event@308 {
			event-name = "STCX_FAIL" ;
			reg = <0x308 0x8>;
			desc = "The number of atomic stores (STCX instructions) that failed" ;
		};
		event@300 {
			event-name = "STCX_FIN" ;
			reg = <0x300 0x8>;
			desc = "The number of STCX instructions that finished" ;
		};
		event@9c8 {
			event-name = "CS_DTLB_MISS_1G" ;
			reg = <0x9c8 0x8>;
			desc = "The number of data TLB misses for 1G page size" ;
		};
		event@10 {
			event-name = "NON_IDLE_INST" ;
			reg = <0x10 0x8>;
			desc = "The number of completed instructions with runlatch enabled during the measurement period" ;
		};
		event@18 {
			event-name = "NON_IDLE_PCYC" ;
			reg = <0x18 0x8>;
			desc = "The number of processor cycles with runlatch enabled during the measurement period" ;
		};
		event@7c8 {
			event-name = "SYNC_PCYC" ;
			reg = <0x7c8 0x8>;
			desc = "The number of processor cycles stalled while waiting for a SYNC operation to complete (DD2 only)" ;
		};
		event@19c8 {
			event-name = "CS_DTLB_MISS_1G_KERNEL" ;
			reg = <0x19c8 0x8>;
			desc = "The number of data TLB misses for 1G page size in kernel state" ;
		};
		event@11c8 {
			event-name = "CS_DTLB_MISS_1G_USER" ;
			reg = <0x11c8 0x8>;
			desc = "The number of data TLB misses for 1G page size in user state" ;
		};
		event@a48 {
			event-name = "CS_CORE_ICT_EMPTY_PCYC" ;
			reg = <0xa48 0x8>;
			desc = "The number of processor cycles the ICT was empty" ;
		};
		event@1a48 {
			event-name = "CS_CORE_ICT_EMPTY_PCYC_KERNEL" ;
			reg = <0x1a48 0x8>;
			desc = "The number of processor cycles the ICT was empty in kernel state" ;
		};
		event@5c0 {
			event-name = "THREAD_NAP_STATE_LOSS_CCYC" ;
			reg = <0x5c0 0x8>;
			desc = "The sum of all constant clock cycles across all SMT threads in Power Savings mode (DD1). The sum of all constant clock cycles across all SMT threads in Power Saving mode where the thread state is not saved (DD2 only). The current event name is for DD2. The event name is CPM_THREAD_NAP_CCYC for DD1" ;
		};
	};
	core {
		compatible = "ibm,imc-counters-core";
		events-prefix = "CPM_";
		scale = "512";
		reg = <0x18 0x8>;
		events = < &CORE_THREAD >;
	};
	thread {
		compatible = "ibm,imc-counters-thread";
		events-prefix = "CPM_";
		scale = "512";
		reg = <0x18 0x8>;
		events = < &CORE_THREAD >;
	};
};
